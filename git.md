
#### 3.3 Ветки - Команда `checkout` при незакомиченных изменениях

`git checkout --force (-f) <commit>` заставит произвести переключение с удалением изменений
`git checkout -f [HEAD]` восстанавливает файлы в состояние на момент последнего коммита

`git stash` позволяет сохранять неоконченные изменения
`git stash pop` и возвращаться к ним 

#### 3.4 Ветки - Перенос незакоммиченных изменений

```bash
git branch <new branch>
git checkout <new branch>
git commit -am "..."
```

#### 3.5 Ветки - Перенос веток "вручную"

```bash
git checkout -b <new_branch>

git branch -f <old_branch> <commit>
git checkout -B <old_branch> <commit>
```


#### 3.7 Ветки - Восстановление предыдущих версий файлов

`git checkout <commit> <path>` восстанавливает файлы по путям в состояние на момент переданного коммита

`git checkout <HEAD> <path>` отменяет изменения до состояния в репозитории в директорию и index
`git checkout <path>` до состояния в index в рабочую директорию

`git checkout -- <path>` позволяет избежать неопределенности 

#### 3.8 Ветки - Просмотр истории и старых файлов, символы ~^@, поиск c :/

`git log <commit> [--oneline]` выводит коммиты, начиная от переданного
`git show <commit>` показывает информацию об объекте

`<commit>~` обращение к родителю
`<commit>~n` обращение к n-ому предку
`HEAD === @`

`git show <commit>:<path>` показывает содержимое файлов на момент коммита
`git show :/<string>` ищет коммит со строкой в описании

#### 3.9 Ветки - Слияние веток "перемоткой"

```bash
git checkout <to branch>
git merge <from branch>
```
сливает ветки "to" и "from"

`ORIG_HEAD` указывает на коммит, с которого вызывалось слияние
`git branch -f <branch> ORIG_HEAD` переносит ветку на идентификатор до слияния

#### 3.10 Ветки - Удаление веток

`git branch -d <branch name>` удаляет ветку, если она объединена с текущей веткой
`git branch -D <branch name>` удаляет ветку независимо от её статуса слияния

#### 3.11 Ветки - История переключений веток: `git reflog`

`git reflog <commit>` выводит рефлог (переключения `HEAD`), нужен для поиска коммитов
`git checkout @{-n}` обращается к предыдущей (или n) ветке, с который был checkout на данную
`git checkout -` переключение на предыдущую ветку

#### 4.1 Удаление лишних файлов и незакоммиченных изменений

```bash
git checkout -f <path>
git reset --hard
```
очищает директорию от незакоммиченных изменений, не трогает untracked files

`git clean [-d] [-x] [-f]` удаляет не отслеживаемые файлы и директории [директории], [игнорируемые файлы], [необходимо]


## 5. Reset

#### 5.1 Жесткий `reset --hard`: отмена, удаление коммитов

`git reset --hard <commit>` устанавливает коммит, на который указывает `HEAD` в переданное состояние, <u>обновляет рабочую директорию и index</u>
`git reset --hard ORIG_HEAD` устанавливает `HEAD` на коммит до последнего reset
`git reset --hard [HEAD]` очищает рабочую директорию и index от незакоммиченных изменений

#### 5.2 Мягкий `reset --soft`: замена и объединение коммитов

`git reset --soft <commit>` переносит ветку на указанный коммит, а <u>рабочую директорию и индекс оставляет как есть</u>

```bash
git reset --soft @~
git add <path>
git commit -c(-C) ORIG_HEAD [--reset-author]
```
добавление файлов в коммит и копирование описания с открытием редактора (или без него), флаг `--reset-author` говорит не копировать автора коммита

#### 5.3 Правка последнего коммита: `commit --amend`

первый шаг - исправить ошибки в рабочей директории и index

`git commit --amend [--reset-author] [--no-edit] [-m]` добавляет изменения в индексе в "текущий" коммит

#### 5.4 Смешанный `reset` (без флагов), сравнение видов `reset`

`git reset [--mixed] <commit> [<path>]` перемещает ветку и обновляет index, но при этом не трогает рабочую директорию

```bash
git reset HEAD 
git reset
git reset <filename>
```
<u>Восстанавливает состояние в индексе</u> до момента коммита (HEAD), не трогая рабочую директорию. Можно выбирать конкретные файлы. Команда обратная `git add`

```bash
git reset <commit> <path>
```
в таком случае, файлы обновляются на состояние, соответствующее коммиту, !но! только в `index`, а не в рабочую директорию , ветка тоже не двигается, в отличие от `git checkout <commit> <path>`


## 6. Просмотр

#### 6.1 Сравнение коммитов, веток и не только: `git diff`

```shell
git diff <commit a> <commit b>
git diff <commit a>..<commit b>
```
показывает изменения между коммитами (игнорируют не отслеживаемые файлы)

`git diff <commit a>...<commit b>` отвечает на вопрос что изменилось в ветке b с момента ее отхождения от ветки a

`git diff <commit>` сравнивает содержимое рабочей директории с репозиторием на момент коммита
`git diff [HEAD]` сравнивает содержимое рабочей директории с index [коммитом в HEAD]
`git diff --cached(--staged) <commit>` показывает проиндексированные изменения, но не помещенные в директорию

![[Pasted image 20241101163436.png]]

`git diff -- <paths>` показывает изменения лишь в указанных файлах
`git diff --name-only <commit a> <commit b>` показывает только имена различающихся файлов, без деталей
`git diff <commit a>:<path a> <commit b>:<path b>` можно сравнивать индивидуальные файлы

#### 6.2 Вывод истории: `git log`, форматирование коммитов

`git log` выводит коммиты, достижимые из HEAD
`git log [--pretty=medium]` задаёт формат вывода

```bash
git log --pretty=oneline --abbrev-commit
git log --oneline
```
выводит компактный лог

`git log --pretty=format:'%h %cd | %s%d [%an]'` вывод можно кастомизировать
`git help log` можно посмотреть список обозначений

`git log --patch(-p)` добавляет к каждому коммиту вывод `diff` того, что в нем было сделано

#### 6.3 Диапазоны коммитов для `git log`

`git log <commits> [--graph] [--all]` для вывода консольного дерева веток из всех веток

```bash
git log <commit b> ^<commit a>
git log <commit a>..<commit b> [--boundary]
```
посмотреть коммиты из ветки "a" с момента расхождения от ветки 'b' [добавляет в вывод пограничный коммит]

`git log <commit a>...<commit b>` выводит комметы обеих веток с момента расхождения
`git log <path>` выводит коммиты, в которых менялся конкретный файл

#### 6.4 Вывод `git log` коммитов, меняющих нужный файл

`git log <log syntax> [-p] -- <paths>` выведет коммиты, в которых менялся файл

#### 6.5 Поиск в истории, фильтры для `git log`

`git log --grep <string> <branch>` позволяет искать коммиты, в описаниях которых есть строка
`git log --grep <string 1> ... -- grep <string n> [--all-match]` флаг можно указывать несколько раз, по умолчанию используется ИЛИ [для использования И]
...

`git log -G<regular expr>` поиск по изменениям

```bash
git log -L a,b:<path>  
git log -L '/<regular expr 1>/', '/<regular expr 2>/':<path>
git log -L :<func name>:<path>
```
поиск изменений в определенных инетрвалах, выводит коммиты в которых были изменения в указанных строках

```shell
git log --author=<string>
git log --commiter=<string>
git log --before <date>
git log --after <date>
```
искать можно по любым полям коммита

**6.6 Кто написал эту строку?** `git blame <path>` показывает модификации файла и их авторов


## 7. Слияние

#### 7.1 "Истинное" слияние и разрешение конфликтов в `git merge`

желательно, чтобы статус был чистый 

`git merge-base <commit 1> <commit 2>` находит общий коммит-предок для веток
`git merge [ours] <theirs>`  

`git checkout --ours <path>` устанавливает файл на состояние сливающей ветки
`git checkout --theirs <path>` устанавливает файл на состояние сливаемой
`git checkout --merge <path>` продолжить процесс слияния

`git reset --hard` прекратит слияние и очистит все изменения

`git reset --merge` оставляет незакоммиченные файлы, не участвующие в слиянии
`git merge --abort` делает то же самое

Команда `git reset --merge` используется для сброса текущего состояния ветки к определённому коммиту, при этом она сохраняет изменения в рабочем каталоге и индексе, которые не конфликтуют с целевым коммитом. Это полезно, когда вы хотите отменить изменения, сделанные в текущей ветке, но при этом сохранить изменения, которые были сделаны в рабочем каталоге.

`git checkout --conflict=diff3 --merge <path>` добавляет то, что было до разделения веток (в base) до изменений в месте конфликта

после разрешения конфликтов:
```bash
git add <path>
git commit -m '...'

git merge --continue
```

#### 7.2 Коммит слияния, дальнейшие слияния

`git show` в коммите слияния показывает идентификаторы родителей, комбинированный сжатый `diff`...

`git show --first-parent` показывает отличия от первого родителя
`git show -m` покажет отличия от всех родителей по отдельности
обычно используется `git diff`

`<commit>^i` обращение к i-тому родителю коммита
`<commit>~i` обращение к i-тому предку коммита
![[Pasted image 20241106122052.png]]

`git branch --merged` показывает ветки, объединенные с текущей
`git branch --no-merged` показывает ветки, не объединенные с текущей

`git merge [<ours>] <theirs> --no-edit` не вызывает редактор, используется, если устраивает автоматическое описание слияния
`git merge <theirs> -m <string>` указать другое описание
`git merge <theirs> --log[=20]` в описание коммита слияния добавляются описания всех сливаемых коммитов с ветки `theirs`

`git log <commit> --first-parent` посмотреть историю разработки основной ветки, без второстепенных, слиток веток

#### 7.3 Отмена слияния

`git reset --hard @~` переходит по ветке первого родителя, коммит слияния больше недостижим 
`git reset --hard <commit>` вернуться на старый коммит слияния

#### 7.4 Семантические конфликты и их разрешение

`git merge <theirs> --no-commit` гит сделает слияние, но остановится перед коммитом, чтобы оказаться в состоянии прерванного слияния
...
```bash
git commit --no-edit
git merge --continue
```

#### 7.5 Сохранение веток с флагом --no-ff

```bash
git merge --no-ff <theirs>
```
заставляет `git merge` всегда вместо перемотки делать коммит слияния

```bash
git config merge.ff false
git config branch.<name>.mergeoptions '--no-ff [-ff]'
```
 настройка конфигурации устанавливает флаг --no-ff по умолчанию

#### 7.6 Создание коммита из ветки: `merge --squash`

`git merge --squash <theirs>` берет изменения из ветки и применяет их к текущему состоянию проекта (раб. директории и индкесу)


## 9. Перемещение коммитов

#### 9.4 Перенос части ветки, `rebase --onto`

```shell
# команда переносит текущую ветку на ветку <target>,
# но не от места расхождения веток (merge-base), 
# а с коммита, указанного в аргументе <starting> 
git rebase --onto <target> <starting>

# можно указать перебазируемую ветку
git rebase --onto <target> <starting> <rebased> 
# ===
git checkout <branch>
git rebase --onto <target> <starting>

# НО rebase вместе с коммитами переносит и ветку,
# что не всегда необходимо, поэтому иногда используют
git cherry-pick <starting>..<rebased>
```

#### 9.5 Перебазирование слияний, `--rebase-merges`

```shell
# при простом перебазировании веток со слиянием
# копируются коммиты из всех слитых веток,
# коммиты слияния при этом пропускаются
git rebase <target>

# для изменения данного поведения используется
# специальный флаг --rebase-merges
git rebase --rebase-merges <target>
```

#### 9.6 Интерактивное перебазирование, `rebase -i`

```sh
# git позволяет подредактировать историю ветки
git rebase -i <target>

# открывается список действий, который собирается
# совершить rebase. в редакторе перед запуском 
# перебазирования rebase дает возможность исправлений
#
# commands:
# pick = использовать коммит
# reword = использовать коммит, но изменить сообщение
# edit = использовать коммит, но остановить rebase
# squash = слить изменения и сообщение с предыдущим коммитом
# fixup = squash, но сообщения коммита отбрасывается
# exec = для добавления произвольных комманд
# drop = пропустить коммит

# для того, чтобы сократить действия при исходной
# генерации списка коммитов
git config rebase.abbreviateCommands true 

# после edit, rebase останавливается, можно
# совершить изменения
git reset --hard <>
# ...
git add <>
git commit

git rebase --edit-todo  # посмотреть и поправить оставшийся список дейсвтий
git rebase --continue  # продолжить перебазирование

# можно перебазировать ветку на саму себя, чтобы 
# отредактировать старый коммит или часть ветки
git rebase -i @~n
```

#### 9.7 Исправляем коммит посередине ветки: `autosquash`

```bash
# autosquash - доп механизм rebase, который делает удобнее
# редактирование коммитов посередине ветки
#
# например, в предыдущий коммит вкралась опечатка.
# подготовим новый коммит-заплатку, исправляющий  
# опечатку, закоммитим исправление, указав специальный 
# флаг с коммитом, который мы хотим поправить
git commit -a --fixup=<commit>

# такая команда добавляет в описание коммита 
# специальные обозначения

# далее при интерактивным перебазировании с опцией
# rebase применит запладку к указанному коммиту
git rebase -i --autosquash
git config --global rebase.autoSquash true  # включить по умолчанию
```

## 10 Отмена коммитов через `revert`

#### 10.1 Обратные коммиты, `revert`

```sh
# предыдущие подходы к отмене коммитов неприменимы
# при работе в команде, если коммиты уже отправлены
# в общий доступ

# в таком случае используется команда revert
git revert <commit>  # применяет изменения, обратные указанному коммиту
git revert <commit A>..<commit B>  # обратить диапазон коммитов
```

#### 10.2 Отмена слияния через `revert`

```sh
# при отмене коммита слияния необходимо указать
# какие именно изменения необходимо обратить
git revert <commit> -m n

# но далее при слиянии этих веток может возникнуть
# ошибка, т.к. некоторые коммиты считаются слитыми

# можно скопировать изменения из старых коммитов
git cherry-pick <commit> -m n

# можно отменить комит отмены. надежнее
git revert <commit>
```

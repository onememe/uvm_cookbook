
# Understanting FuseSoc

## The components of FuseSoc

FuseSoC - пакетный менеджер и система сборки HDL кода
Фундаментальная сущность в FuseSoC - ядро (core). Ядра могут быть найдены пакетным менеджером в локальных или удаленных местах и скомбинированы в полное аппаратное устройство с помощью системы сборки.

#### FuseSoC's basic building block: cores

Ядро - разумно обособленная, переиспользуемая часть IP, как, например, реализация FIFO. В других контекстах такая же концепция называется пакетом или программной библиотекой.

У ядра в FuseSoC есть имя типа `example:ip:fifo`. Имя и другая информация о ядре, как список исходных файлов содержится и описывается в файле, называемом файл ядра (core file). Названия таких файлов заканчиваются на "`.core`".

Файлы ядра также могут содержать зависимости от других ядер. Например, "FIFO core" может зависеть от "SRAM core".

#### Discover cores: the package manager

Ядра FuseSoC могут храниться во многих местах, локальных или удаленных. Искать ядра и создавать список ядер, доступных для пользователя - работа пакетного менеджера FuseSoC.

Fusesoc ищет пакеты в настраиваем наборе библиотек (core libraries). В самом простом случае библиотека ядер это просто директория с ядрами, как часто бывает в  hardware проектах. Для того, чтобы поддерживать более продвинутые кейсы переиспользования и обнаружения кода Fusesoc также использует удаленные библиотеки ядер. Удаленная библиотека может быть ключом, открывающим возможность переиспользовать IP, особенно в крупных корпоративных средах или проектах с открытым исходным кодом.

#### From cores to a whole system: the build system

Система сборки Fusesoc разрешает зависимости между ядрами, начиная с ядра верхнего уровня (top-level core). Такое ядро - технически, очередное Fusesoc ядро, но со специальным значением: оно является точкой входа в устройство. Выходом разрешения зависимостей является список исходных файлов и другие мета данные, необходимые EDA (electronic design automation) tool чтобы собрать (синтезировать, смоделировать, дополнить...) верхний уровень устройства. На процесс разрешения зависимостей могут влиять ограничения (constraints). Ограничения фактически являются входными переменными для процесса сборки и отражают такие параметры как цель сборки, используемый EDA tool и многое другое. 

#### From a file list to a synthesized design: EDAlize it!

После сборки системы собрала все исходные файлы и параметры дизайна, пришло время перейти к инструментам сборки.

Fusesoc поддерживает множество часто используемых частных и открытых EDA инструментов, и может быть легко расширен для поддержки других инструментов.

## Concepts of the FuseSoC build system

Для того, чтобы понять, как Fusesoc собирает устройство, необходимо понять три базовых концепции: `tool flows`, `targets` и `build stages`. 

#### Tool flows

Tool flow (поток инструментов, "tool" or "EDA tool") - часть программных операций над устройством для его анализа, симуляции, трансформации и т. д. Частые категории  потока инструментов - симуляторы, инструменты для синтеза или статического анализа. Например, Verilator, Xilinx Vivado, Synopsys Design Compiler...

FuseSoC старается минимизировать разницы между тулами, чтобы было возможно легкое переключение между ними. Например, необходимо необходимо поменять только команду запуска Fusesoc в консоли, чтобы симулировать устройство на Synopsys вместо Icarus. Конечно, кастомизированные настройки для конкретных инструментов все равно возможны, если они необходимы.

#### Targets

Над hardware устройством можно провести множество операций: синтезировать, симулировать, анализировать с помощью lint инструментов и т. д. Хотя все это производится над одним и тем же устройством, есть различия: параметры устройства, исходные файлы или поведенчиская модель IP блока. В Fusesoc цель (`target`) - это группа таких настроек. Пользователь может свободно называть таргеты. Часто используемые цели - одна для симуляции (обычно называется `sim`), одна для FPGA или ASIC синтеза (`synth`), и еще одна для анализа (`lint`). 

#### Build stages

Fusesoc собирает дизайн в три этапа: setup, build и run.

1. `setup` - первый шаг, устройство сшивается воедино и подготавливается к передаче потоку инструментов.
    1. Создается дерево зависимостей, начиная с ядра верхнего уровня
    2. Генераторы (специальные ядра с динамическим поведением) вызываются. Ядра, созданные генераторами, также вставляются в древо зависимостей.
    3. Дерево зависимостей преобразовывается для создания сглаженного вида дизайна. Вся информация об устройстве записывается в EDAM файл.
    4. Вызываются специальные процедуры установки потока инструментов.
2. `build` запускается tool flow, пока не будет создан какой-либо выходной файл.
3. `run` - каким-либо образом "выполняет" выходные файлы `build`. Как именно, зависит от потока инструментов: для потока симуляции, выполняется симуляция. Для анализа, lint tool...


# Running FuseSoC

FuseSoC - инструмент командной строки.

## Build a design

Группа команд `fusesoc run` используется для установки, сборки и запуска устройства. Конкретные предпринимаемые действия зависят от потока инструментов.

`fusesoc run [-h]`


# Building a design with FuseSoC

Система сборки Fusesoc собирает вместе аппаратное устройство из отдельных ядер.
Собрать дизайн означает вызвать поток инструментов, чтобы создать некоторые выходные данные и исполнить их. В зависимости от цели и выбранного потока инструментов процесс сборки может делать и продуцировать совершенно разные вещи.

Два необходимых для сборки устройства с помощью Fusesoc шага:

1. Написать хотя бы один файл описания FuseSoC ядра.
2. Вызвать `fusesoc run`

## Writing core files

Ядро описывается в core файле.

Core файлы написаны в синтаксисе YAML и следуют CAPI 2 версии.

#### Things one should know about YAML

 - Пробелы имеют значение
 - Следует думать о нем, как о иерархической типизированной структуре данных (в нем есть списки, словари, числа, строки и т. д.).
 - Синтаксис предоставляет множество путей описания одной и той же структуры

```YAML
# list can be written by two ways
["item1", "item2"]
# is identical to
- "item1"
- "item2"

# the same for dictionaries:
{ key1: "value1", key2: "value2"}
# is identical to
key1: "value1"
key2: "value2"
```

#### An example: the blinky core

#### Naming the core file

Файл ядра может иметь любое название, но он должен иметь расширение (`.core`) рекомендуется, чтобы имя файла совпадало с именем ядра.

#### The first line: `CAPI=2`

Файл ядра всегда начинается строкой `CAPI=2`. Что-либо другое (включая комментарии) перед этой строкой недопустимо, т.к. Fusesoc использует первую строку, чтобы различать различные версии CAPI.

#### The core name, version, and description

У каждого ядра есть имя, переданное по ключу `name`. Имя выбирается свободно, но необходимо следовать общей структуре, называемой VLNV (четыре части имени ядра, разделяемые двоеточием: Vendor, Library, Name и Version).

Версия - три числа в виде `major.minor.patch` 

Ядра также могут иметь описание, передаваемое по ключу `description`. Опционально, но рекомендуется.

```YAML
name: fusesoc:examples:blinky:1.0.0
description: "Blinky, a FuseSoC example core"
```

#### Specifying source files

Ядро обычно состоит из одного или нескольких исходных файлов. Исходные файлы группируются в наборы под ключом `filesets`.

Fusesoc не определяет ни конкретные правила группирования, ни именования наборов файлов. Обычно один набор используют для RTL файлов, и один для файлов тестового окружения.

```YAML
filesets:
  rtl:
    files:
      - rtl/blinky.sv
      - rtl/macros.svh:
          is_include_file: true
    file_type: systemVerilogSource
```

Для каждого набора файлов поддерживается несколько ключей:
- `files`: упорядоченный список исходных файлов
- `file_type`: тип по умолчанию для всех файлов в списке `files`
- `depend`: зависимости от других ядер

#### Source files

Исходные файлы ищутся относительно расположения файла ядра и должны храниться в той же директории, что и ядро, или в его поддиректории. Пути к исходным файлам не могут быть абсолютными, или путями с обращениями к родительскому каталогу.

Исходные файлы могут иметь атрибуты. Чтобы указать атрибуты, после имени файла ставится двоеточие и ниже указываются атрибуты как пары ключ-значение. (Альтернативно, можно указать атрибуты в фигурных скобках)

Наиболее часто встречаются атрибуты:

- `is_include_file`: Файл - включаемый файл. Это означает, что файл не передается тулу напрямую, а вместо этого он включается(`include`) в другой исходный файл. Fusesoc гарантирует, что инструмент найдет включаемый файл, например, передавая в tool соответствующий путь.
- `file_type`: перезаписывает тип данных, заданный по умолчанию у набора, на другой, для конкретного файла

#### File types

Описывает тип исходного файла. Fusesoc не использует эту информацию, но передает ее в backend тула, который затем конфигурируется в соответствии от обнаруженного типа.

Чаще всего используются типы файлов:

- `verilogSource`: исходный код Verilog. Файлы имеют расширение .v или .vh
- `systemVerilogSource`: исходный код SystemVerilog, расширения .sv/.svh
- `vhdlSource`: VHDL код

#### Targets
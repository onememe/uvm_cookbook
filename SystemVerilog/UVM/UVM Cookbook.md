
# UVM Basics

## UVM Basics

Эта глава вводит в концепции, которые должен знать читатель для того, чтобы понять содержимое `cookbook`.

## Testbench Basics

UVM использует многоуровневый объекто-ориентированный подход для разработки тестовых окружений. UVM позволяет получать в результате модульные, переиспользуемые верификационные окружения, что позволяет тестировщику думать на уровне транзакций и фокусироваться на верификации.

Тестируемое устройство (ТУ/Design Under Test, DUT) - соединяется со слоем транзакторов, которые коммуницируют с ним на уровне выходов, а с остальным тестовым окружением UVM с помощью объектов транзакций. Слой тестового окружения над транзакторным состоит из компонентов, взаимодействующих на уровне транзакций. 

![[Pasted image 20241212184349.png]]

Низший уровень тестового окружения интерфейсо-зависим. Для каждого интерфейса UVM предоставляет агента (agent), который содержит драйвер (driver), монитор (monitor), секвенсор (sequencer) и, опционально, сборщик покрытия (coverage collector). Агент воплощает в себе специфичные для протокола коммуникации с ТУ. Агент и другие специфичные для устройства компоненты инкапсулированы в `uvm_env` компоненте окружения (environment), которое, в свою очередь, создается и настраивается `uvm_test` компонентной верхнего уровня.

`uvm_sequence_item` (элемент последовательности) - иногда упоминается как транзакция - это uvm_object, `содержащий` поля данных, необходимые для реализации протокола и коммуникации с тестируемым устройством. `uvm_driver` преобразовывает `sequence_item` в сигналы на выводах для того, чтобы отправить или прочесть информацию от ТУ. `sequence_item` поставляются одним или более объектами `uvm_sequence`, они определяют стимулы на уровне транзакций и исполняются с помощью `uvm_sequencer` компонента агента. Сиквенсор отвечает за выполнение последовательностей, разрешение споров между ними и проведение элементов последовательности между драйвером и последовательностью (sequence).

`uvm_monitor` пассивно наблюдает за поведением сигнального уровня интерфейса ТУ, преобразовывает сигналы в элементы последовательности и предоставляет эти элементы анализирующим компонентам в агенте или где-либо еще в тестовом окружении (сборщики покрытия или скорборды). В агентах также есть объект конфигурации, позволяющий тестировщику управлять аспектами агента при сборке и выполнении тестового окружения.

Предоставляя единый интерфейс тестового окружения, агент изолирует его и последовательности UVM от деталей реализации интерфейса. Так, последовательность, предоставляющая пакеты данных, может быть переиспользована разными агентами UVM, реализующими различные протоколы. В окружении UVM обычно для каждого интерфейса тестового устройства существует свой агент.

Для данного устройства компоненты инкапсулируются в компонент окружения `uvm_env`, который обычно специфичен для устройства. Как и агент, окружение обычно содержит свой объект конфигурации, позволяющий тесту управлять аспектами окружения так же, как и управлять агентом внутри этого окружения. Окружения могут быть собраны внутри другого окружения верхнего уровня. Как блочные устройства могут быть собраны в подсистемы и системы, блочные окружения, соответствующие блоку, могут быть переиспользованы как компоненты в подсистемном уровне окружения, которое в свою очередь может быть переиспользовано как тестовое окружение системного уровня.

Как только окружение/среда будет определена, `uvm_test` создаст его экземпляр, сконфигурирует и соберет, включая кастомизированные ключевые аспекты тестового окружения в целом (вариации используемых в окружении компонент, запускаемых последовательностей, конфигурационных объектов окружения, подокружений и агентов в тестовом окружении).

UVM тест начинается с `initial` блока на верхнем уровне HVL модуля вызовом  `run_test()`.


## UVM Components

Тестовое окружение UVM состоит из компонентов - объектов, наследующихся от базового класса `uvm_component`. Когда создается объект класса, наследуемого от `uvm_component`, он становится частью иерархии тестового окружения, которая существует на протяжении всего времени симуляции. Это контрастирует с веткой последовательности в классовой иерархии UVM, которая включает в себя недолговечные объекты - объекты, которые создаются, используются и уничтожаются (сборщиком мусора) после удаления ссылки на них.

![[Pasted image 20241213132504.png]]

(Квази) статичная иерархия компонентов в UVM используется инфраструктурой отчётности, чтобы вывести область видимости компоненты, выводящей сообщение, также конфигурационным процессом, чтобы определить какие компоненты могут иметь доступ к конфигурационном объекту, а также фабрикой UVM, чтобы применять переопределения. Эта иерархия компонентов представляется связанным списком, постепенно увеличивающимся по мере создания каждого компонента. Иерархическое положение каждой компоненты определено переданными аргументами: именем и родителем, переданными в метод создания во время конструирования. 

Например, фрагмент кода ниже - компонента `apb_agent`, создается внутри `spi_env`. Предполагая, что `spi_env` создается в компоненте теста верхнего уровня и имеет имя `m_env`, иерархический путь агента - конкатенация имени компоненты окружения `uvm_test_top.m_env`, оператора точки `.` и имени, переданного первым аргументом в метод `create()`, результирующее иерархическое имя для агента - `uvm_test_top.m_env.m_apb_agent`. Любые ссылки к агенту должны использовать это строковое имя.

```systemverilog
/* Hierarchical name example */
class spi_env extends uvm_env;
	// ...
	apb_agent m_apb_agent;  // declaration of the apb agent handle
	// ...
	function void build_phase(uvm_phase phase);
		m_apb_agent = apg_agent::type_id::create("m_apb_agent", this);
	endfunction: build_phase
	// ...
endclass: spi_env
```

Класс `uvm_component` наследуется от класса `uvm_report_object`, который лежит в самом сердце инфраструктуры сообщений UVM.  Процесс отчетности использует статическую иерархию, чтобы добавить область расположения компоненты в строку сообщения.

Шаблон базового класса `uvm_component`содержит виртуальный метод для каждой фазы UVM и они должны быть реализованы пользователем по мере необходимости. Если виртуальный метод какой-либо фазы не реализован, компонента эффективно не принимает участия в этой фазе.

Базовый класс также поддерживает таблицу конфигурации. При использовании API `uvm_config_db` статическая иерархия используется как часть механизма нахождения пути, чтобы управлять доступом компонентов к конфигурационному объекту.

Для гибкости конфигурирования и более умного построения конфигурации, компоненты UVM регистрируются в фабрике UVM (UVM factory). Фабрика позволяет менять компоненты на другие, совместимые производные типы используя переопределение. Это удобная техника для изменения функциональности тестового окружения без изменений в коде напрямую, что потребует перекомпиляции и будет препятствовать переиспользованию.

Пакет UVM содержит несколько расширений класса `uvm_component` для общепринятых компонентов тестового окружения. Большинство из них очень "стройны", являются буквально небольшими расширениями базового класса. Хотя все еще можно наследоваться от `uvm_component`, встроенные расширения "документируют" код. Вдобавок, в них есть утилиты для анализа, которые также используют эти посторонние классы как ключи, чтобы установить картину тестовой иерархии. С другой стороны, некоторые встроенные расширения `uvm_component` являются строительными блоками, имеющими более глубокое значение за счет создания конкретных под-компонентов.

![[Pasted image 20241213142236.png]]

## The UVM Factory

### The UVM Factory

Предназначение фабрики - возможность объект одного типа заместить объектом  унаследованного типа без изменений структуры тестового окружения или даже его кода. Механизм называется переопределением по типу либо экземпляру. Заменяемые компоненты должны быть полиморфически совместимы. Это включает в себя необходимость создания заменяемым компонентом тех же самых TLM интерфейсов и объектов. В добавок, для работы фабрики должны соблюдаться некоторые соглашения о кодировании.

### Factory Coding Convention 1: Registration

Компонента или объект должны содержать код регистрации в фабрике, состоящий из следующих элементов:

- Обертку `uvm_component_registry`, тип которой определен как `type_id`
- Статическую функцию получения `type_id`
- Функцию получения имени типа

Пример:

```systemverilog
class my_component extends uvm_component;
	// wrapper class around the component class that is
	// used within the factory
	typedef uvm_component_registry #(my_component, "my_component") type_id;

	// used to get the type_id wrapper
	static function type_id get_type();
		return type_id::get();
	endfunction

	// used to get the type_name as a string
	function string get_type_name();
		return "my_component";
	endfunction

	// ...
endclass: my_component
```

У кода регистрации есть стандартный шаблон, который может быть сгенерирован одним из четырех макросов регистрации в фабрике:

```systemverilog
// for a component
class my_component extends uvm_component;
	// component factory registration macro
	`uvm_component_utils(my_component)
	...

// for a parameterized component
class my_param_component #(int ADD_WIDTH=20, int DATA_WIDTH=23)
	extends uvm_component;

	typedef my_param_component #(ADD_WIDTH, DATA_WIDTH) this_t;
	// parameterized component factory registration macro
	`uvm_component_param_utils(this_t)
	...

// for a class derived from an object (i.e. uvm_object,
// uvm_transaction, uvm_sequence_item, uvm_sequence etc.)
class my_item extends uvm_sequence_item;
	`uvm_object_utils(my_item)
	...

// for a parameterized object class
class my_item #(int ADD_WIDTH=20, int DATA_WIDTH=20)
	extends uvm_sequence_item;

	typedef my_item #(ADD_WIDTH, DATA_WIDTH) this_t;
	`uvm_object_param_utils(this_t)
	...
```

### Factory Coding Convention 2: Constructor Defaults

Конструкторы компонент и объектов - виртуальные методы с прототипом шаблона, которого должны придерживаться пользователи. 